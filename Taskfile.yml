version: "3"

dotenv:
  - .env

vars:
  API_URL:
    sh: |
      fqdn="{{.BUBLIK_FQDN}}"
      prefix="{{.URL_PREFIX}}"
      port="{{.BUBLIK_DOCKER_PROXY_PORT}}"
      fqdn="${fqdn%/}"
      prefix="${prefix#/}"
      prefix="${prefix%/}"
      if [ -n "$prefix" ]; then
        echo "$fqdn:$port/$prefix"
      else
        echo "$fqdn:$port"
      fi
  BACKUP_DIR:
    sh: echo "${CLI_ARGS:-backups}"
  LOGS_URL:
    sh: |
      fqdn="{{.BUBLIK_FQDN}}"
      prefix="{{.URL_PREFIX}}"
      port="{{.BUBLIK_DOCKER_PROXY_PORT}}"
      fqdn="${fqdn%/}"
      prefix="${prefix#/}"
      prefix="${prefix%/}"
      if [ "$port" = "80" ] || [ "$port" = "443" ]; then
        if [ -n "$prefix" ]; then
          echo "$fqdn/$prefix/logs/"
        else
          echo "$fqdn/logs/"
        fi
      else
        if [ -n "$prefix" ]; then
          echo "$fqdn:$port/$prefix/logs/"
        else
          echo "$fqdn:$port/logs/"
        fi
      fi

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  ###########################################
  #         Git                             #
  ###########################################
  init:
    desc: Initialize Git submodules
    summary: Initialize and update all Git submodules recursively
    aliases: [i]
    status:
      - |
        # Check if all submodules are initialized and up to date
        test -z "$(git submodule status | grep '^-\|^+')"
    cmds:
      - git submodule init
      - git submodule update --init --recursive

  update:
    desc: Update Git submodules to latest commits
    summary: Update all Git submodules to their latest remote commits
    aliases: [u]
    status:
      - |
        # Check if any submodule needs updating
        test -z "$(git submodule status | grep '^+')"
    cmds:
      - git submodule update --remote

  ###########################################
  #         Docker Environment              #
  ###########################################
  docker:setup:
    desc: Setup Docker environment (copy env and settings files)
    summary: |
      Prepare Docker environment by copying necessary configuration files
      Uses BUBLIK_DOCKER_DATA_DIR from env
    aliases: [setup]
    deps: [check-deps]
    silent: true
    cmds:
      - task: docker:setup:env
      - task: docker:setup:django-settings

  docker:setup:django-settings:
    desc: Copy django settings template
    internal: true
    silent: true
    cmds:
      - ./scripts/setup_settings.sh

  docker:setup:env:
    desc: Copy .env.local to .env
    internal: true
    status:
      - test -f .env
    silent: true
    cmds:
      - ./scripts/setup_env.sh
      - task: docker:setup:env:uid

  docker:setup:env:uid:
    desc: Add host UID/GID to .env
    internal: true
    silent: true
    vars:
      HOST_UID:
        sh: id -u
      HOST_GID:
        sh: id -g
    cmds:
      - |
        if [ -f .env ]; then
          # Create temporary file
          tmp_env=$(mktemp)
          
          # Process existing .env file
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip lines that set HOST_UID or HOST_GID
            if [[ ! "$line" =~ ^HOST_(UID|GID)= ]]; then
              echo "$line" >> "$tmp_env"
            fi
          done < .env
          
          # Add HOST_UID and HOST_GID
          echo "HOST_UID={{.HOST_UID}}" >> "$tmp_env"
          echo "HOST_GID={{.HOST_GID}}" >> "$tmp_env"
          
          # Replace original .env with updated version
          mv "$tmp_env" .env
        fi

  docker:dev:watch:
    desc: Start development environment in watch mode
    summary: |
      Start development environment with live reload capability
      Environment will be accessible at {{.API_URL}}
    deps: [docker:setup]
    aliases: [dev:watch]
    cmds:
      - docker compose -f docker-compose.dev.yml up --build --watch
      - echo "üöÄ Development environment started at {{.API_URL}}"

  docker:dev:up:
    desc: Start development environment
    deps: [docker:setup]
    aliases: [dev:up]
    silent: true
    cmds:
      - docker compose -f docker-compose.dev.yml up --build -d
      - echo "üöÄ Development environment started at {{.API_URL}}"

  docker:up:
    desc: Start production environment
    summary: |
      Start production environment with optimized settings
      Environment will be accessible at BUBLIK_FQDN
    deps: [docker:setup]
    aliases: [up]
    silent: true
    cmds:
      - docker compose -f docker-compose.yml up --build -d
      - echo "üöÄ Production environment started at {{.API_URL}}"

  docker:dev:stop:
    desc: Stop Docker development environment
    summary: Stop development containers while preserving data
    aliases: [dev:stop]
    cmds:
      - docker compose -f docker-compose.dev.yml down

  docker:stop:
    desc: Stop Docker production environment
    summary: Stop and remove production containers while preserving data
    aliases: [stop]
    cmds:
      - docker compose -f docker-compose.yml down

  docker:down:
    desc: Stop Docker development environment
    summary: Stop and remove production containers while preserving data
    aliases: [down]
    cmds:
      - docker compose -f docker-compose.yml down

  docker:dev:down:
    desc: Stop Docker development environment
    summary: Stop and remove development containers while preserving data
    aliases: [dev:down]
    cmds:
      - docker compose -f docker-compose.dev.yml down

  import-log:
    desc: Import logs from a specified .tar file
    summary: |
      Import logs from a specified .tar file
      Usage: task import-logs -- ./path/to/file.tar
      Warning: task import-logs -- /path/to/file.tar Does not work with localhost
    silent: true
    vars:
      FILE: "{{.CLI_ARGS}}"
    cmds:
      - ./scripts/import_logs.sh {{.FILE}}

  docker:nuke:
    prompt: |
      This will remove all containers, volumes, and unused images and logs.
      YOU WILL LOSE ALL YOUR DATA!!!
      YOU WILL LOSE ALL YOUR DATA!!!
      YOU WILL LOSE ALL YOUR DATA!!!
      Are you sure you want to continue? [y/N]
    desc: Clean Docker environment (images, volumes, and logs)
    aliases: [nuke]
    cmds:
      - docker compose -f docker-compose.dev.yml down -v
      - docker compose -f docker-compose.yml down -v
      - docker system prune -af
      - task: docker:nuke:remove-data
      - test -f .env && rm .env

  docker:nuke:remove-data:
    desc: Remove Docker data directory
    silent: true
    internal: true
    cmds:
      - |
        if [ -n "${BUBLIK_DOCKER_DATA_DIR}" ] && [ -d "${BUBLIK_DOCKER_DATA_DIR}" ]; then
          echo "Removing ${BUBLIK_DOCKER_DATA_DIR}..."
          rm -rf "${BUBLIK_DOCKER_DATA_DIR}"
        fi

  ###########################################
  #         Deps                          #
  ###########################################

  check-deps:
    desc: Check if system dependencies are installed
    summary: Verify that all required system and Docker dependencies are available
    cmds:
      - task: system:check-deps
      - task: docker:check-deps

  system:check-deps:
    desc: Check if system dependencies are installed
    internal: true
    silent: true
    cmds:
      - ./scripts/check_deps.sh system

  docker:check-deps:
    desc: Check if Docker and Docker Compose are installed
    internal: true
    silent: true
    cmds:
      - ./scripts/check_deps.sh docker

  ###########################################
  #         Shortcuts                       #
  ###########################################
  meta-categorization:
    desc: Trigger meta-categorization process
    summary: |
      Start the meta-categorization process for test results
      Connects to API_URL endpoint
    silent: true
    cmds:
      - ./scripts/meta_categorization.sh "{{.API_URL}}"

  ###########################################
  #         Bootstrap                       #
  ###########################################
  bootstrap-dev:
    desc: Bootstrap the application and deploy to development environment
    summary: |
      Complete development deployment process:
      1. Start Docker containers in dev mode
      2. Initialize configurations
      3. Import initial sessions
      4. Display admin credentials
    preconditions:
      - test -f .env
      - test -f ./bublik/bublik/settings.py
    cmds:
      - task: docker:dev:up
      - cmd: echo "Waiting for 15 seconds for services to start..." && sleep 15
      - task: bootstrap:init-configs
      - task: bootstrap:import-sessions
      - task: bootstrap:print-credentials

  bootstrap:
    desc: Bootstrap the application and deploy to production
    summary: |
      Complete production deployment process:
      1. Start Docker containers
      2. Initialize configurations
      3. Import initial sessions
      4. Display admin credentials
    preconditions:
      - test -f .env
      - test -f ./bublik/bublik/settings.py
    cmds:
      - task: docker:up
      - cmd: echo "Waiting for 15 seconds for services to start..." && sleep 15
      - task: bootstrap:init-configs
      - task: bootstrap:import-sessions
      - task: print-env-info

  print-env-info:
    desc: Print environment information
    silent: true
    cmds:
      - |
        echo "üîë Admin credentials:"
        echo "  Email: {{.DJANGO_SUPERUSER_EMAIL}}"
        echo "  Password: {{.DJANGO_SUPERUSER_PASSWORD}}"
        echo "üîë Data directory:"
        echo "  {{.BUBLIK_DOCKER_DATA_DIR}}"
        echo "üîë INSTANCE URL:"
        echo "  {{.API_URL}}"

  bootstrap:import-sessions:
    desc: Import Test Sessions from specified file
    summary: |
      Import test sessions from a specified file containing URLs
      Usage: task bootstrap:import-sessions -- /path/to/import.txt
      Default file: bootstrap/import.txt
    deps: [auth:get-token]
    silent: true
    vars:
      IMPORT_FILE:
        sh: echo "${CLI_ARGS:-bootstrap/import.txt}"
    cmds:
      - ./scripts/import_sessions.sh "{{.API_URL}}" "{{.IMPORT_FILE}}"
      - defer: { task: auth:get-token:clean }

  bootstrap:init-configs:
    desc: Bootstrap Configs from specified directory
    summary: |
      Bootstrap configuration files from a specified directory
      Usage: task bootstrap:init-configs -- /path/to/config/dir
      Default directory: bootstrap/
    silent: true
    deps: [auth:get-token]
    vars:
      CONFIG_DIR:
        sh: echo "${CLI_ARGS:-bootstrap}"
    cmds:
      - ./scripts/bootstrap_configs.sh "{{.API_URL}}" "{{.EMAIL}}" "{{.PASSWORD}}" "{{.CONFIG_DIR}}" "{{.LOGS_URL}}"
      - defer: { task: auth:get-token:clean }

  auth:get-token:
    desc: Get access token by logging in
    summary: |
      Get authentication token by logging in with provided credentials
      Uses DJANGO_SUPERUSER_EMAIL and DJANGO_SUPERUSER_PASSWORD from env
    internal: true
    silent: true
    vars:
      EMAIL: '{{.DJANGO_SUPERUSER_EMAIL | default "admin@bublik.com"}}'
      PASSWORD: '{{.DJANGO_SUPERUSER_PASSWORD | default "admin"}}'
    cmds:
      - mkdir -p ./tmp
      - |
        echo "üîë Logging in with {{.EMAIL}}..."
        response=$(curl -s -c ./tmp/cookies.txt "{{.API_URL}}/auth/login/" \
          -H 'Content-Type: application/json' \
          --data-raw "{\"email\":\"{{.EMAIL}}\",\"password\":\"{{.PASSWORD}}\"}")

        if grep -q "access_token" ./tmp/cookies.txt; then
          echo "‚úÖ Successfully logged in"
          token=$(grep "access_token" ./tmp/cookies.txt | cut -f7)
          echo "$token" > ./tmp/.access_token
          echo "‚úÖ Token saved to ./tmp/.access_token"
        else
          echo "‚ùå Login failed"
          echo "$response"
          exit 1
        fi

  auth:get-token:clean:
    desc: Clean up access token
    summary: Remove temporary authentication files
    internal: true
    cmds:
      - rm -f ./tmp/cookies.txt ./tmp/.access_token

  ###########################################
  #         Backup Operations              #
  ###########################################
  backup:create:
    desc: Create a complete backup of database and TE logs
    silent: true
    summary: |
      Create a complete backup archive containing both database and TE logs
      Usage: task backup:create -- /path/to/backup/dir
      Default directory: ./backups/
    cmds:
      - ./scripts/backup_operations.sh create {{.BACKUP_DIR}}

  backup:restore:
    desc: Restore both database and TE logs from a backup archive
    silent: true
    summary: |
      Restore complete backup from an archive
      Usage: task backup:restore -- /path/to/backup.tar.gz
    cmds:
      - ./scripts/backup_operations.sh restore {{.CLI_ARGS}}

  backup:list:
    desc: List available backup archives
    silent: true
    summary: |
      List all backup archives in the backup directory
      Usage: task backup:list -- /path/to/backup/dir
      Default directory: ./backups/
    cmds:
      - ./scripts/backup_operations.sh list {{.BACKUP_DIR}}
